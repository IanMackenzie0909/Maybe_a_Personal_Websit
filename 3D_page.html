<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <title>3D 運鏡教學：3D 上帝視角 + 2D 取景器</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin: 0; height: 100%; background:#111; color:#eee; font-family: system-ui, -apple-system, "Noto Sans TC", Arial; }
    #ui {
      position: fixed; left: 12px; top: 12px; z-index: 10; background: rgba(0,0,0,.6);
      padding: 12px; border-radius: 10px; backdrop-filter: blur(6px); box-shadow: 0 8px 24px rgba(0,0,0,.35);
    }
    #ui label { display:block; font-size:12px; color:#bbb; margin: 8px 0 4px; }
    #ui select, #ui button, #ui input[type=range] {
      width: 240px; padding: 6px 8px; border-radius: 8px; border: 1px solid #333; background:#181818; color:#eee;
    }
    #ui .row { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;}
    #ui button { cursor:pointer; }
    #credits { position:fixed; right:12px; bottom:12px; color:#777; font-size:12px; }
    canvas { display:block; width:100%; height:100%; }
    /* 右側 2D 取景器外框（在上帝視角中可視化相機視錐） */
    .badge {
      position: fixed; right: 18px; top: 12px; background: rgba(0,0,0,.5); padding: 6px 10px; border-radius: 999px; font-size: 12px; color: #ddd;
    }
  </style>
</head>
<body>
  <div id="ui">
    <label>運鏡手法</label>
    <select id="moveStyle">
      <option value="idle">靜止（可用搖桿/轉頭）</option>
      <option value="orbit">Orbit 環繞</option>
      <option value="dolly">Dolly 推拉</option>
      <option value="truck">Truck 橫移</option>
      <option value="arc">Arc 弧形運動</option>
      <option value="boom">Boom 升降</option>
    </select>

    <label>景別（距離）</label>
    <select id="shotSize">
      <option value="close">CLOSE-SHOT（近）</option>
      <option value="medium" selected>MEDIUM-SHOT（中）</option>
      <option value="wide">WIDER-SHOT（遠）</option>
    </select>

    <label>機位角度</label>
    <select id="angle">
      <option value="eye" selected>眼平</option>
      <option value="low">低角度</option>
      <option value="high">高角度</option>
      <option value="bird">鳥瞰</option>
      <option value="dutch">荷蘭式（傾斜）</option>
    </select>

    <label>鏡頭焦距（視角）</label>
    <input id="fov" type="range" min="20" max="90" step="1" value="45" />
    <div class="row">
      <button id="play">▶ 播放</button>
      <button id="pause">⏸ 暫停</button>
      <button id="reset">↺ 重置位置</button>
    </div>
    <div style="margin-top:8px; font-size:12px; color:#9aa;">
      左：3D 上帝視角（可拖曳）｜右：2D 取景器（攝影機實際畫面）
    </div>
  </div>
  <div class="badge">2D 取景器</div>
  <canvas id="c"></canvas>
  <div id="credits">Three.js demo · 兩視口渲染</div>

  <!-- Three.js + 控制器（官方 CDN） -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/controls/OrbitControls.js": "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ====== 基本場景 ======
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x101014);

    // 環境光 + 方向光
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(5, 6, 3);
    scene.add(dir);

    // 地面與輔助
    const grid = new THREE.GridHelper(20, 20, 0x333333, 0x222222);
    grid.position.y = -1;
    scene.add(grid);

    const axes = new THREE.AxesHelper(1.2);
    axes.position.set(0, -0.99, 0);
    scene.add(axes);

    // ====== 目標物（中心）======
    const targetGroup = new THREE.Group();
    scene.add(targetGroup);

    const core = new THREE.Mesh(
      new THREE.SphereGeometry(0.7, 48, 32),
      new THREE.MeshStandardMaterial({ color: 0x87b7ff, roughness: 0.3, metalness: 0.1 })
    );
    core.position.y = -0.1;
    targetGroup.add(core);

    const stand = new THREE.Mesh(
      new THREE.CylinderGeometry(0.12, 0.2, 1.4, 24),
      new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.8 })
    );
    stand.position.y = -0.3 - 0.7;
    targetGroup.add(stand);

    // 一些環繞小物，讓運鏡時有視覺參考
    for (let i=0; i<8; i++){
      const angle = (i/8) * Math.PI * 2;
      const r = 3.5 + (i%2)*0.6;
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.4, 0.4),
        new THREE.MeshStandardMaterial({ color: 0x9ad29a, roughness: 0.6 })
      );
      box.position.set(Math.cos(angle)*r, -0.8, Math.sin(angle)*r);
      scene.add(box);
    }

    // ====== 兩台相機：A = 上帝視角，B = 取景器（拍攝機）======
    const godCam = new THREE.PerspectiveCamera(55, 1, 0.1, 100);
    godCam.position.set(7, 4.5, 7);
    godCam.lookAt(0, 0, 0);

    const controls = new OrbitControls(godCam, renderer.domElement);
    controls.target.set(0, -0.2, 0);
    controls.enableDamping = true;

    // 拍攝機安裝在「機身 Rig」上，方便做 Orbit/Dolly/Truck/升降 等組合
    const camRig = new THREE.Group(); // 旋轉中心（環繞）
    const camSlider = new THREE.Group(); // 推拉距離（半徑）
    const camElevator = new THREE.Group(); // 升降
    const camBody = new THREE.Group(); // 相機本體（可做傾斜/抖動等）

    camRig.add(camSlider);
    camSlider.add(camElevator);
    camElevator.add(camBody);
    scene.add(camRig);

    const filmCam = new THREE.PerspectiveCamera(45, 1, 0.05, 100);
    filmCam.position.set(0, 0, 0);    // 相機放在機身結點 origin
    camBody.add(filmCam);

    // 相機初始配置
    let baseRadius = 4.5;   // 與目標距離（Dolly）
    let baseHeight = 1.5;   // 機位高度
    let baseAzimuth = -Math.PI/6; // 方位角（Orbit 起點）

    // 設定 Rig 初始狀態
    function applyRig(radius=baseRadius, height=baseHeight, azimuth=baseAzimuth){
      camSlider.position.set(0, 0, 0);
      camElevator.position.set(0, height, 0);
      camSlider.position.x = radius; // 把半徑放在 X，讓 camRig 自轉產生環繞
      camRig.rotation.y = azimuth;
      filmCam.lookAt(-radius, -height, 0); // 往目標中心
    }
    applyRig();

    // 視錐輔助（在 3D 視角裡看到拍攝機的「看到什麼」）
    const camHelper = new THREE.CameraHelper(filmCam);
    scene.add(camHelper);

    // ====== UI 元件 ======
    const selStyle = document.getElementById('moveStyle');
    const selShot  = document.getElementById('shotSize');
    const selAngle = document.getElementById('angle');
    const rangeFov = document.getElementById('fov');
    const btnPlay  = document.getElementById('play');
    const btnPause = document.getElementById('pause');
    const btnReset = document.getElementById('reset');

    // ====== Shot presets（距離 + FOV）======
    function setShotSize(preset){
      if (preset==='close'){ baseRadius = 2.2; filmCam.fov = 40; }
      else if (preset==='medium'){ baseRadius = 4.5; filmCam.fov = 45; }
      else { baseRadius = 7.5; filmCam.fov = 55; }
      rangeFov.value = filmCam.fov|0;
      applyRig(baseRadius, baseHeight, baseAzimuth);
      filmCam.updateProjectionMatrix();
    }

    // ====== Angle presets（機位角度 + 傾斜）======
    function setAngle(preset){
      if (preset==='eye'){ baseHeight = 1.5; camBody.rotation.z = 0; }
      else if (preset==='low'){ baseHeight = 0.5; camBody.rotation.z = 0; }
      else if (preset==='high'){ baseHeight = 3.5; camBody.rotation.z = 0; }
      else if (preset==='bird'){ baseHeight = 6.5; camBody.rotation.z = 0; }
      else if (preset==='dutch'){ baseHeight = 1.5; camBody.rotation.z = THREE.MathUtils.degToRad(10); }
      applyRig(baseRadius, baseHeight, baseAzimuth);
    }

    selShot.addEventListener('change', e => setShotSize(e.target.value));
    selAngle.addEventListener('change', e => setAngle(e.target.value));
    rangeFov.addEventListener('input', e => {
      filmCam.fov = parseFloat(e.target.value);
      filmCam.updateProjectionMatrix();
      camHelper.update();
    });

    // 初始套用
    setShotSize(selShot.value);
    setAngle(selAngle.value);

    // ====== 動畫：各種運鏡 ======
    let playing = false;
    let tAccum = 0;    // 時間累計，用於週期運動

    function animateRig(dt){
      const style = selStyle.value;
      const speed = 0.6;
      const twoPi = Math.PI * 2;

      if (style === 'idle'){
        // 靜止：可加微小呼吸感
        const wobble = Math.sin(tAccum*0.5)*0.02;
        camBody.rotation.x = wobble;
      }
      else if (style === 'orbit'){ // 環繞
        baseAzimuth += dt * speed * 0.8;
      }
      else if (style === 'dolly'){ // 推拉
        const r = baseRadius + Math.sin(tAccum*0.8)*0.8;
        applyRig(r, baseHeight, baseAzimuth);
        return;
      }
      else if (style === 'truck'){ // 橫移（繞目標切線方向移動）
        const r = baseRadius;
        const phase = Math.sin(tAccum*0.9)*1.0;
        camSlider.position.x = r;
        camElevator.position.y = baseHeight;
        // 在相機本地座標的 Z 軸上左右移
        camBody.position.set(0, 0, phase);
      }
      else if (style === 'arc'){ // 弧形（結合 Orbit + Dolly 微動）
        baseAzimuth += dt * speed * 0.6;
        const r = baseRadius + Math.sin(tAccum*0.6)*0.5;
        applyRig(r, baseHeight, baseAzimuth);
        return;
      }
      else if (style === 'boom'){ // 升降
        const h = baseHeight + Math.sin(tAccum*0.9) * 1.2;
        applyRig(baseRadius, h, baseAzimuth);
        return;
      }

      applyRig(baseRadius, baseHeight, baseAzimuth);
    }

    btnPlay.addEventListener('click', ()=>{ playing = true; });
    btnPause.addEventListener('click', ()=>{ playing = false; });
    btnReset.addEventListener('click', ()=>{
      playing = false;
      baseRadius = 4.5; baseHeight = 1.5; baseAzimuth = -Math.PI/6;
      camBody.position.set(0,0,0);
      camBody.rotation.set(0,0,0);
      selStyle.value = 'idle';
      selShot.value = 'medium';
      selAngle.value = 'eye';
      filmCam.fov = 45; rangeFov.value = 45;
      filmCam.updateProjectionMatrix();
      applyRig();
    });

    // ====== 兩個「視口」在同一個 Renderer 上繪製 ======
    function setRendererSize(){
      const w = window.innerWidth;
      const h = window.innerHeight;
      renderer.setSize(w, h, false);
    }
    window.addEventListener('resize', setRendererSize);
    setRendererSize();

    // ====== 畫面更新 ======
    const clock = new THREE.Clock();

    function render(){
      const dt = clock.getDelta();
      tAccum += playing ? dt : 0;

      if (playing) animateRig(dt);

      controls.update();
      camHelper.update();

      const w = renderer.domElement.width;
      const h = renderer.domElement.height;

      // 左：3D 上帝視角（占 55% 寬）
      const leftW = Math.floor(w * 0.55);
      renderer.setViewport(0, 0, leftW, h);
      renderer.setScissor(0, 0, leftW, h);
      renderer.setScissorTest(true);
      godCam.aspect = leftW / h;
      godCam.updateProjectionMatrix();
      renderer.render(scene, godCam);

      // 右：2D 取景器（攝影機視角，45%）
      const rightX = leftW;
      const rightW = w - leftW;
      renderer.setViewport(rightX, 0, rightW, h);
      renderer.setScissor(rightX, 0, rightW, h);
      renderer.setScissorTest(true);
      filmCam.aspect = rightW / h;
      filmCam.updateProjectionMatrix();
      renderer.render(scene, filmCam);

      // 片門遮幅（給 2D 視窗加一點「拍片感」：上下輕度 letterbox）
      const ctx = renderer.getContext();
      ctx.save();
      ctx.disable(ctx.DEPTH_TEST);
      const lb = Math.max(0, Math.floor(h * 0.06));
      ctx.fillStyle = "rgba(0,0,0,0.55)";
      ctx.fillRect(rightX, 0, rightW, lb);
      ctx.fillRect(rightX, h-lb, rightW, lb);
      ctx.restore();

      requestAnimationFrame(render);
    }
    render();

    // ====== 鍵盤快捷鍵 ======
    window.addEventListener('keydown', (e)=>{
      const k = e.key.toLowerCase();
      if (k===' '){ playing = !playing; }
      if (k==='1') selStyle.value = 'idle';
      if (k==='2') selStyle.value = 'orbit';
      if (k==='3') selStyle.value = 'dolly';
      if (k==='4') selStyle.value = 'truck';
      if (k==='5') selStyle.value = 'arc';
      if (k==='6') selStyle.value = 'boom';
    });
  </script>
</body>
</html>